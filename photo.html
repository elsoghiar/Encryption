<!DOCTYPE html>
<html lang="ar">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ğŸ”’ ØªØ´ÙÙŠØ± Ø§Ù„Ù†Øµ Ø¯Ø§Ø®Ù„ Ø§Ù„ØµÙˆØ±</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.1.1/crypto-js.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/eruda"></script>
    <script> eruda.init(); </script>

    <style>
        body { font-family: Arial, sans-serif; text-align: center; direction: rtl; background-color: #f5f5f5; }
        .container { max-width: 500px; margin: auto; padding: 20px; border: 1px solid #ccc; border-radius: 10px; background: white; }
        input, textarea, button { margin: 10px; padding: 10px; font-size: 16px; width: 80%; }
        canvas { display: none; }
    </style>
</head>
<body>

    <h2>ğŸ” ØªØ´ÙÙŠØ± Ø§Ù„Ù†Øµ Ø¯Ø§Ø®Ù„ ØµÙˆØ±Ø© ÙˆÙÙƒ ØªØ´ÙÙŠØ±Ù‡</h2>

    <div class="container">
        <h3>Ø¥Ø®ÙØ§Ø¡ Ø§Ù„Ù†Øµ Ø¯Ø§Ø®Ù„ ØµÙˆØ±Ø©</h3>
        <input type="file" id="imageInput" accept="image/*"><br>
        <textarea id="textToHide" placeholder="ğŸ“ Ø£Ø¯Ø®Ù„ Ø§Ù„Ù†Øµ Ù‡Ù†Ø§"></textarea><br>
        <input type="password" id="encryptionKey" placeholder="ğŸ”‘ Ø£Ø¯Ø®Ù„ Ù…ÙØªØ§Ø­ Ø§Ù„ØªØ´ÙÙŠØ± (Ø§Ø®ØªÙŠØ§Ø±ÙŠ)"><br>
        <button onclick="hideTextInImage()">ğŸ” ØªØ´ÙÙŠØ± Ø§Ù„Ù†Øµ</button>
        <a id="downloadLink" style="display:none;" download="encrypted.png">â¬‡ï¸ ØªØ­Ù…ÙŠÙ„ Ø§Ù„ØµÙˆØ±Ø© Ø§Ù„Ù…Ø´ÙØ±Ø©</a>
    </div>

    <br>

    <div class="container">
        <h3>ğŸ” Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„Ù†Øµ Ù…Ù† ØµÙˆØ±Ø©</h3>
        <input type="file" id="imageDecodeInput" accept="image/*"><br>
        <input type="password" id="decryptionKey" placeholder="ğŸ”‘ Ø£Ø¯Ø®Ù„ Ù…ÙØªØ§Ø­ ÙÙƒ Ø§Ù„ØªØ´ÙÙŠØ± (Ø¥Ù† ÙˆØ¬Ø¯)"><br>
        <button onclick="extractTextFromImage()">ğŸ” ÙÙƒ Ø§Ù„ØªØ´ÙÙŠØ±</button>
        <p id="extractedText"></p>
    </div>
    <div class="bottom-nav">
                <a href="index.html" class="nav-item">
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-align-left">
                        <path d="M15 12H3" />
                        <path d="M17 18H3" />
                        <path d="M21 6H3" />
                    </svg>
                </a>
                <a href="photo.html" class="nav-item">
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-image">
                        <rect width="18" height="18" x="3" y="3" rx="2" ry="2" />
                        <circle cx="9" cy="9" r="2" />
                        <path d="m21 15-3.086-3.086a2 2 0 0 0-2.828 0L6 21" />
                    </svg>
                </a>
                <a href="improve.html" class="nav-item">
                    <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M19 14c1.49-1.46 3-3.21 3-5.5A5.5 5.5 0 0 0 16.5 3c-1.76 0-3 .5-4.5 2-1.5-1.5-2.74-2-4.5-2A5.5 5.5 0 0 0 2 8.5c0 2.3 1.5 4.05 3 5.5l7 7Z" />
                        <path d="M12 5 9.04 7.96a2.17 2.17 0 0 0 0 3.08c.82.82 2.13.85 3 .07l2.07-1.9a2.82 2.82 0 0 1 3.79 0l2.96 2.66" />
                        <path d="m18 15-2-2" />
                        <path d="m15 18-2-2" />
                    </svg>
                </a>
            </div>
</div>

    <canvas id="canvas"></canvas>

    <script>
        const DEFAULT_KEY = "SuperSecureKey123!@#"; // Ù…ÙØªØ§Ø­ Ø§ÙØªØ±Ø§Ø¶ÙŠ

        function hideTextInImage() {
            const fileInput = document.getElementById('imageInput');
            const textInput = document.getElementById('textToHide').value;
            let encryptionKey = document.getElementById('encryptionKey').value || DEFAULT_KEY;

            if (!fileInput.files[0] || !textInput) {
                alert("âš ï¸ ÙŠØ±Ø¬Ù‰ Ø§Ø®ØªÙŠØ§Ø± ØµÙˆØ±Ø© ÙˆØ¥Ø¯Ø®Ø§Ù„ Ù†Øµ.");
                return;
            }

            const reader = new FileReader();
            reader.onload = function(event) {
                const img = new Image();
                img.src = event.target.result;

                img.onload = function() {
                    const canvas = document.getElementById('canvas');
                    const ctx = canvas.getContext('2d');

                    canvas.width = img.width;
                    canvas.height = img.height;
                    ctx.drawImage(img, 0, 0);

                    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                    const pixels = imageData.data;

                    // ğŸ” ØªØ´ÙÙŠØ± Ø§Ù„Ù†Øµ Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… CryptoJS
                    const encryptedText = CryptoJS.AES.encrypt(textInput, encryptionKey).toString();

                    let binaryText = '';
                    for (let i = 0; i < encryptedText.length; i++) {
                        binaryText += encryptedText.charCodeAt(i).toString(2).padStart(8, '0');
                    }

                    if (binaryText.length > pixels.length / 4) {
                        alert("âš ï¸ Ø§Ù„Ù†Øµ Ø·ÙˆÙŠÙ„ Ø¬Ø¯Ù‹Ø§ Ø¨Ø§Ù„Ù†Ø³Ø¨Ø© Ù„Ù‡Ø°Ù‡ Ø§Ù„ØµÙˆØ±Ø©.");
                        return;
                    }

                    // ØªÙˆØ²ÙŠØ¹ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø´ÙØ±Ø© Ø¹Ù„Ù‰ Ø§Ù„Ù‚Ù†ÙˆØ§Øª Ø§Ù„Ù„ÙˆÙ†ÙŠØ©
                    let index = 0;
                    for (let i = 0; i < pixels.length && index < binaryText.length; i += 4) {
                        pixels[i] = (pixels[i] & 0xFE) | parseInt(binaryText[index]); // Ù‚Ù†Ø§Ø© R
                        pixels[i + 1] = (pixels[i + 1] & 0xFE) | parseInt(binaryText[index + 1] || '0'); // Ù‚Ù†Ø§Ø© G
                        pixels[i + 2] = (pixels[i + 2] & 0xFE) | parseInt(binaryText[index + 2] || '0'); // Ù‚Ù†Ø§Ø© B
                        index += 3;
                    }

                    ctx.putImageData(imageData, 0, 0);

                    const encryptedImage = canvas.toDataURL("image/png");
                    const downloadLink = document.getElementById('downloadLink');
                    downloadLink.href = encryptedImage;
                    downloadLink.style.display = 'block';

                    // ğŸ§¹ Ù…Ø³Ø­ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø¨Ø¹Ø¯ Ø§Ù„ØªØ´ÙÙŠØ±
                    document.getElementById('imageInput').value = '';
                    document.getElementById('textToHide').value = '';
                    document.getElementById('encryptionKey').value = '';
                };
            };
            reader.readAsDataURL(fileInput.files[0]);
        }

        function extractTextFromImage() {
            const fileInput = document.getElementById('imageDecodeInput');
            let decryptionKey = document.getElementById('decryptionKey').value || DEFAULT_KEY;

            if (!fileInput.files[0]) {
                alert("âš ï¸ ÙŠØ±Ø¬Ù‰ Ø§Ø®ØªÙŠØ§Ø± ØµÙˆØ±Ø© Ù„ÙÙƒ Ø§Ù„ØªØ´ÙÙŠØ±.");
                return;
            }

            const reader = new FileReader();
            reader.onload = function(event) {
                const img = new Image();
                img.src = event.target.result;

                img.onload = function() {
                    const canvas = document.getElementById('canvas');
                    const ctx = canvas.getContext('2d');

                    canvas.width = img.width;
                    canvas.height = img.height;
                    ctx.drawImage(img, 0, 0);

                    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                    const pixels = imageData.data;

                    let binaryText = '';
                    for (let i = 0; i < pixels.length; i += 4) {
                        binaryText += (pixels[i] & 1).toString();
                        binaryText += (pixels[i + 1] & 1).toString();
                        binaryText += (pixels[i + 2] & 1).toString();
                    }

                    let extractedText = '';
                    for (let i = 0; i < binaryText.length; i += 8) {
                        const byte = binaryText.substr(i, 8);
                        const charCode = parseInt(byte, 2);
                        if (charCode === 0) break;
                        extractedText += String.fromCharCode(charCode);
                    }

                    try {
                        extractedText = CryptoJS.AES.decrypt(extractedText, decryptionKey).toString(CryptoJS.enc.Utf8);
                        document.getElementById('extractedText').innerText = "ğŸ”“ Ø§Ù„Ù†Øµ Ø§Ù„Ù…Ø³ØªØ®Ø±Ø¬: " + extractedText;
                    } catch (error) {
                        alert("âš ï¸ Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ù†Øµ ØµØ§Ù„Ø­ Ø£Ùˆ Ø§Ù„Ù…ÙØªØ§Ø­ ØºÙŠØ± ØµØ­ÙŠØ­.");
                    }
                };
            };
            reader.readAsDataURL(fileInput.files[0]);
        }
    </script>

</body>
</html>
